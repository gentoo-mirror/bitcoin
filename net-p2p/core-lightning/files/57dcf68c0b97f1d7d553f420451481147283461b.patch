--- /var/cache/distfiles/57dcf68c0b97f1d7d553f420451481147283461b.patch	2023-01-12 23:58:58.532429912 -0500
+++ /var/tmp/portage/net-p2p/core-lightning-0.11.2-r112/temp/57dcf68c0b97f1d7d553f420451481147283461b.patch	2023-01-13 00:09:08.941822798 -0500
@@ -22,7 +22,7 @@
 index 30ac1f700c7..d47430aab66 100644
 --- a/plugins/libplugin-pay.c
 +++ b/plugins/libplugin-pay.c
-@@ -3284,34 +3284,31 @@ static struct command_result *direct_pay_listpeers(struct command *cmd,
+@@ -3272,26 +3272,23 @@ static struct command_result *direct_pay_listpeers(struct command *cmd,
  						   const jsmntok_t *toks,
  						   struct payment *p)
  {
@@ -35,43 +35,26 @@
 -		struct listpeers_peer *peer = r->peers[0];
 -		if (!peer->connected)
 -			goto cont;
--
++	for (size_t i=0; i<tal_count(channels); i++) {
++		struct listpeers_channel *chan = channels[i];
+ 
 -		for (size_t i=0; i<tal_count(peer->channels); i++) {
 -			struct listpeers_channel *chan = r->peers[0]->channels[i];
 -			if (!streq(chan->state, "CHANNELD_NORMAL"))
 -			    continue;
--
--			/* Must have either a local alias for zeroconf
--			 * channels or a final scid. */
--			assert(chan->alias[LOCAL] || chan->scid);
--			d->chan = tal(d, struct short_channel_id_dir);
--			if (chan->scid) {
--				d->chan->scid = *chan->scid;
--				d->chan->dir = *chan->direction;
--			} else {
--				d->chan->scid = *chan->alias[LOCAL];
--				d->chan->dir = 0; /* Don't care. */
--			}
-+	for (size_t i=0; i<tal_count(channels); i++) {
-+		struct listpeers_channel *chan = channels[i];
-+
 +		if (!chan->connected)
 +			continue;
-+
+ 
+-			d->chan = tal(d, struct short_channel_id_dir);
+-			d->chan->scid = *chan->scid;
+-			d->chan->dir = *chan->direction;
+-		}
 +		if (!streq(chan->state, "CHANNELD_NORMAL"))
 +			continue;
 +
-+		/* Must have either a local alias for zeroconf
-+		 * channels or a final scid. */
-+		assert(chan->alias[LOCAL] || chan->scid);
 +		d->chan = tal(d, struct short_channel_id_dir);
-+		if (chan->scid) {
-+			d->chan->scid = *chan->scid;
-+			d->chan->dir = *chan->direction;
-+		} else {
-+			d->chan->scid = *chan->alias[LOCAL];
-+			d->chan->dir = 0; /* Don't care. */
- 		}
++		d->chan->scid = *chan->scid;
++		d->chan->dir = *chan->direction;
  	}
 -cont:
 +
@@ -83,8 +66,8 @@
 --- a/plugins/libplugin.c
 +++ b/plugins/libplugin.c
 @@ -1914,15 +1914,6 @@ static struct listpeers_channel *json_to_listpeers_channel(const tal_t *ctx,
- 			    json_get_member(buffer, tok, "spendable_msat"),
- 			*aliastok = json_get_member(buffer, tok, "alias");
+ 			*smsattok =
+ 			    json_get_member(buffer, tok, "spendable_msat");
  
 -	if (privtok == NULL || privtok->type != JSMN_PRIMITIVE ||
 -	    statetok == NULL || statetok->type != JSMN_STRING ||
@@ -126,13 +109,13 @@
 -	    (netaddrtok != NULL && netaddrtok->type != JSMN_ARRAY) ||
 -	    channelstok == NULL || channelstok->type != JSMN_ARRAY)
 -		return NULL;
--
--	res = tal(ctx, struct listpeers_peer);
--	json_to_node_id(buffer, idtok, &res->id);
--	json_to_bool(buffer, conntok, &res->connected);
 +	json_to_node_id(buffer, idtok, &id);
 +	json_to_bool(buffer, conntok, &connected);
  
+-	res = tal(ctx, struct listpeers_peer);
+-	json_to_node_id(buffer, idtok, &res->id);
+-	json_to_bool(buffer, conntok, &res->connected);
+-
 -	res->netaddr = tal_arr(res, const char *, 0);
 -	if (netaddrtok != NULL) {
 -		json_for_each_arr(i, iter, netaddrtok) {
@@ -166,15 +149,15 @@
  	const jsmntok_t *iter;
 -	struct listpeers_result *res;
 -	const jsmntok_t *peerstok = json_get_member(buffer, toks, "peers");
--
++	const jsmntok_t *peerstok = json_get_member(buffer, tok, "peers");
++	struct listpeers_channel **chans;
+ 
 -	if (peerstok == NULL || peerstok->type != JSMN_ARRAY)
 -		return NULL;
 -
 -	res = tal(ctx, struct listpeers_result);
 -	res->peers = tal_arr(res, struct listpeers_peer *, 0);
-+	const jsmntok_t *peerstok = json_get_member(buffer, tok, "peers");
-+	struct listpeers_channel **chans;
- 
+-
 -	json_for_each_obj(i, iter, peerstok) {
 -		struct listpeers_peer *p =
 -		    json_to_listpeers_peer(res, buffer, iter);
