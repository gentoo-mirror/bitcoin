https://github.com/ElementsProject/lightning/pull/6646

From ab5066c3956707b21bdeb13dae43e90d1797051f Mon Sep 17 00:00:00 2001
From: Matt Whitlock <c-lightning@mattwhitlock.name>
Date: Mon, 4 Sep 2023 04:08:32 -0400
Subject: [PATCH 1/3] lightningd/test: use tmpdir_mkstemp() to create log file

Changelog-None
---
 lightningd/test/run-log_filter.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/lightningd/test/run-log_filter.c b/lightningd/test/run-log_filter.c
index be53d73a0fc..e46f01eb5d9 100644
--- a/lightningd/test/run-log_filter.c
+++ b/lightningd/test/run-log_filter.c
@@ -118,7 +118,7 @@ int main(int argc, char *argv[])
 	struct log_book *lb;
 	struct node_id node_id;
 	struct lightningd *ld;
-	char tmpfiletemplate[] = "/tmp/run-log_filter.XXXXXX";
+	char *tmpfile;
 
 	common_setup(argv[0]);
 
@@ -131,8 +131,8 @@ int main(int argc, char *argv[])
 	ld->log = new_logger(ld, lb, NULL, "dummy");
 	assert(arg_log_to_file("-", ld) == NULL);
 
-	assert(mkstemp(tmpfiletemplate) >= 0);
-	assert(arg_log_to_file(tmpfiletemplate, ld) == NULL);
+	assert(tmpdir_mkstemp(tmpctx, "run-log_filter.XXXXXX", &tmpfile) >= 0);
+	assert(arg_log_to_file(tmpfile, ld) == NULL);
 
 	/* Log level default. */
 	assert(opt_log_level("BROKEN", lb) == NULL);
@@ -224,7 +224,7 @@ int main(int argc, char *argv[])
 	assert(try_log(lb, "prefix", NULL, LOG_IO_IN) == 0);
 
 	/* File exception: tmpfile logs everything */
-	assert(opt_log_level(tal_fmt(tmpctx, "io::%s", tmpfiletemplate), lb) == NULL);
+	assert(opt_log_level(tal_fmt(tmpctx, "io::%s", tmpfile), lb) == NULL);
 	assert(try_log(lb, "stdout1", NULL, LOG_BROKEN) == 2);
 	assert(try_log(lb, "stdout1", NULL, LOG_INFORM) == 2);
 	assert(try_log(lb, "stdout1", NULL, LOG_DBG) == 2);

From c4c9b447b1d99d72ef59cdfbbc588038368d0a06 Mon Sep 17 00:00:00 2001
From: Matt Whitlock <c-lightning@mattwhitlock.name>
Date: Mon, 4 Sep 2023 04:03:19 -0400
Subject: [PATCH 2/3] common/utils: add str_expand()

Changelog-None
---
 common/test/run-str_expand.c | 155 +++++++++++++++++++++++++++++++++++
 common/utils.c               | 133 ++++++++++++++++++++++++++++++
 common/utils.h               |  59 +++++++++++++
 3 files changed, 347 insertions(+)
 create mode 100644 common/test/run-str_expand.c

diff --git a/common/test/run-str_expand.c b/common/test/run-str_expand.c
new file mode 100644
index 00000000000..4154ce4e098
--- /dev/null
+++ b/common/test/run-str_expand.c
@@ -0,0 +1,155 @@
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <common/amount.h>
+#include <common/setup.h>
+#include <common/utils.h>
+
+/* AUTOGENERATED MOCKS START */
+/* Generated stub for amount_asset_is_main */
+bool amount_asset_is_main(struct amount_asset *asset UNNEEDED)
+{ fprintf(stderr, "amount_asset_is_main called!\n"); abort(); }
+/* Generated stub for amount_asset_to_sat */
+struct amount_sat amount_asset_to_sat(struct amount_asset *asset UNNEEDED)
+{ fprintf(stderr, "amount_asset_to_sat called!\n"); abort(); }
+/* Generated stub for amount_sat */
+struct amount_sat amount_sat(u64 satoshis UNNEEDED)
+{ fprintf(stderr, "amount_sat called!\n"); abort(); }
+/* Generated stub for amount_sat_add */
+ bool amount_sat_add(struct amount_sat *val UNNEEDED,
+				       struct amount_sat a UNNEEDED,
+				       struct amount_sat b UNNEEDED)
+{ fprintf(stderr, "amount_sat_add called!\n"); abort(); }
+/* Generated stub for amount_sat_div */
+struct amount_sat amount_sat_div(struct amount_sat sat UNNEEDED, u64 div UNNEEDED)
+{ fprintf(stderr, "amount_sat_div called!\n"); abort(); }
+/* Generated stub for amount_sat_eq */
+bool amount_sat_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
+{ fprintf(stderr, "amount_sat_eq called!\n"); abort(); }
+/* Generated stub for amount_sat_greater_eq */
+bool amount_sat_greater_eq(struct amount_sat a UNNEEDED, struct amount_sat b UNNEEDED)
+{ fprintf(stderr, "amount_sat_greater_eq called!\n"); abort(); }
+/* Generated stub for amount_sat_mul */
+bool amount_sat_mul(struct amount_sat *res UNNEEDED, struct amount_sat sat UNNEEDED, u64 mul UNNEEDED)
+{ fprintf(stderr, "amount_sat_mul called!\n"); abort(); }
+/* Generated stub for amount_sat_sub */
+ bool amount_sat_sub(struct amount_sat *val UNNEEDED,
+				       struct amount_sat a UNNEEDED,
+				       struct amount_sat b UNNEEDED)
+{ fprintf(stderr, "amount_sat_sub called!\n"); abort(); }
+/* Generated stub for amount_sat_to_asset */
+struct amount_asset amount_sat_to_asset(struct amount_sat *sat UNNEEDED, const u8 *asset UNNEEDED)
+{ fprintf(stderr, "amount_sat_to_asset called!\n"); abort(); }
+/* Generated stub for amount_tx_fee */
+struct amount_sat amount_tx_fee(u32 fee_per_kw UNNEEDED, size_t weight UNNEEDED)
+{ fprintf(stderr, "amount_tx_fee called!\n"); abort(); }
+/* Generated stub for fromwire */
+const u8 *fromwire(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, void *copy UNNEEDED, size_t n UNNEEDED)
+{ fprintf(stderr, "fromwire called!\n"); abort(); }
+/* Generated stub for fromwire_bool */
+bool fromwire_bool(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
+{ fprintf(stderr, "fromwire_bool called!\n"); abort(); }
+/* Generated stub for fromwire_fail */
+void *fromwire_fail(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
+{ fprintf(stderr, "fromwire_fail called!\n"); abort(); }
+/* Generated stub for fromwire_secp256k1_ecdsa_signature */
+void fromwire_secp256k1_ecdsa_signature(const u8 **cursor UNNEEDED, size_t *max UNNEEDED,
+					secp256k1_ecdsa_signature *signature UNNEEDED)
+{ fprintf(stderr, "fromwire_secp256k1_ecdsa_signature called!\n"); abort(); }
+/* Generated stub for fromwire_sha256 */
+void fromwire_sha256(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, struct sha256 *sha256 UNNEEDED)
+{ fprintf(stderr, "fromwire_sha256 called!\n"); abort(); }
+/* Generated stub for fromwire_tal_arrn */
+u8 *fromwire_tal_arrn(const tal_t *ctx UNNEEDED,
+		       const u8 **cursor UNNEEDED, size_t *max UNNEEDED, size_t num UNNEEDED)
+{ fprintf(stderr, "fromwire_tal_arrn called!\n"); abort(); }
+/* Generated stub for fromwire_u32 */
+u32 fromwire_u32(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
+{ fprintf(stderr, "fromwire_u32 called!\n"); abort(); }
+/* Generated stub for fromwire_u64 */
+u64 fromwire_u64(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
+{ fprintf(stderr, "fromwire_u64 called!\n"); abort(); }
+/* Generated stub for fromwire_u8 */
+u8 fromwire_u8(const u8 **cursor UNNEEDED, size_t *max UNNEEDED)
+{ fprintf(stderr, "fromwire_u8 called!\n"); abort(); }
+/* Generated stub for fromwire_u8_array */
+void fromwire_u8_array(const u8 **cursor UNNEEDED, size_t *max UNNEEDED, u8 *arr UNNEEDED, size_t num UNNEEDED)
+{ fprintf(stderr, "fromwire_u8_array called!\n"); abort(); }
+/* Generated stub for towire */
+void towire(u8 **pptr UNNEEDED, const void *data UNNEEDED, size_t len UNNEEDED)
+{ fprintf(stderr, "towire called!\n"); abort(); }
+/* Generated stub for towire_bool */
+void towire_bool(u8 **pptr UNNEEDED, bool v UNNEEDED)
+{ fprintf(stderr, "towire_bool called!\n"); abort(); }
+/* Generated stub for towire_secp256k1_ecdsa_signature */
+void towire_secp256k1_ecdsa_signature(u8 **pptr UNNEEDED,
+			      const secp256k1_ecdsa_signature *signature UNNEEDED)
+{ fprintf(stderr, "towire_secp256k1_ecdsa_signature called!\n"); abort(); }
+/* Generated stub for towire_sha256 */
+void towire_sha256(u8 **pptr UNNEEDED, const struct sha256 *sha256 UNNEEDED)
+{ fprintf(stderr, "towire_sha256 called!\n"); abort(); }
+/* Generated stub for towire_u32 */
+void towire_u32(u8 **pptr UNNEEDED, u32 v UNNEEDED)
+{ fprintf(stderr, "towire_u32 called!\n"); abort(); }
+/* Generated stub for towire_u64 */
+void towire_u64(u8 **pptr UNNEEDED, u64 v UNNEEDED)
+{ fprintf(stderr, "towire_u64 called!\n"); abort(); }
+/* Generated stub for towire_u8 */
+void towire_u8(u8 **pptr UNNEEDED, u8 v UNNEEDED)
+{ fprintf(stderr, "towire_u8 called!\n"); abort(); }
+/* Generated stub for towire_u8_array */
+void towire_u8_array(u8 **pptr UNNEEDED, const u8 *arr UNNEEDED, size_t num UNNEEDED)
+{ fprintf(stderr, "towire_u8_array called!\n"); abort(); }
+/* AUTOGENERATED MOCKS END */
+
+
+static const char *subst_falken(const void *game, const char *name, size_t namelen)
+{
+	static int counter;
+
+	switch (namelen) {
+		case 3:
+			if (memcmp(name, "adj", 3) == 0)
+				return ++counter <= 3 ? "nice" :
+					/* intentionally misbehave */ "fantastic";
+			break;
+		case 4:
+			if (memcmp(name, "game", 4) == 0)
+				return (const char *) game;
+			break;
+	}
+	return NULL;
+}
+
+int main(int argc, char *argv[])
+{
+	static const char *defaults[] = { "TMPDIR=/tmp", NULL };
+	char *str;
+
+	common_setup(argv[0]);
+
+	setenv("PREFIX", "/usr", true);
+	setenv("BINDIR", "/bin", true);
+	str = str_expand(tmpctx, "${PREFIX}${BINDIR}/lightningd", subst_getenv, NULL);
+	assert(streq("/usr/bin/lightningd", str));
+
+	unsetenv("TMPDIR");
+	str = str_expand(tmpctx, "$TMPDIR/\\$test.log", subst_getenv, defaults);
+	assert(streq("/tmp/$test.log", str));
+
+	setenv("TMPDIR", "/var/tmp", true);
+	str = str_expand(tmpctx, "$TMPDIR/\\$test.log", subst_getenv, defaults);
+	assert(streq("/var/tmp/$test.log", str));
+
+	str = str_expand(tmpctx, "$1How about a ${adj} ${game of $game?", subst_falken, "chess");
+	assert(streq("How about a nice ${game of chess?", str));
+
+	/* Intentional bug in subst_falken() initially says $adj is "nice" during
+	   length calculation but then illegally switches that to "fantastic"
+	   during catenation, thereby causing the output to be truncated. */
+	str = str_expand(tmpctx, "$1How about a ${adj} ${game of $game?", subst_falken, "global thermonuclear war");
+	assert(streq("How about a fantastic ${game of global thermonuclear", str));
+
+	common_shutdown();
+	return 0;
+}
diff --git a/common/utils.c b/common/utils.c
index 0c9ecc5ae27..fc0ccbf8ef4 100644
--- a/common/utils.c
+++ b/common/utils.c
@@ -1,4 +1,5 @@
 #include "config.h"
+#include <assert.h>
 #include <bitcoin/chainparams.h>
 #include <ccan/list/list.h>
 #include <ccan/str/hex/hex.h>
@@ -180,3 +181,135 @@ char *str_lowering(const void *ctx, const char *string TAKES)
 	for (char *p = ret; *p; p++) *p = tolower(*p);
 	return ret;
 }
+
+static bool iswordc(int c)
+{
+	return isalnum(c) || c == '_';
+}
+
+static size_t wordlen(const char *str)
+{
+	size_t len = 0;
+	while (iswordc((unsigned char) str[len])) ++len;
+	return len;
+}
+
+static size_t numlen(const char *str)
+{
+	size_t len = 0;
+	while (isdigit((unsigned char) str[len])) ++len;
+	return len;
+}
+
+char *str_expand(const void *ctx,
+                 const char *str TAKES,
+                 const char *TAKES (*subst)(const void *ptr,
+                                            const char *name,
+                                            size_t namelen),
+                 const void *ptr)
+{
+	char *ret, *r;
+	const char *p, *sub;
+	size_t len = 0, namelen = (size_t) -1;
+
+	// count how many chars we'll produce
+	for (p = str; *p;)
+		if (*p == '\\' && p[1])
+			++len, p += 2;
+		else if (*p == '$') {
+			const char *name = ++p;
+			if (*p == '{') {
+				namelen = wordlen(name = ++p);
+				if (name[namelen] != '}') {
+					len += 2; // ${
+					continue;
+				}
+				p += namelen + 1; // }
+			}
+			else if (isdigit((unsigned char) *p))
+				p += (namelen = 1 + numlen(p + 1));
+			else if (iswordc((unsigned char) *p))
+				p += (namelen = 1 + wordlen(p + 1));
+			else {
+				++len; // $
+				continue;
+			}
+			sub = subst(ptr, name, namelen);
+			if (sub)
+				len += strlen(sub);
+			if (taken(sub))
+				tal_free(sub);
+		}
+		else
+			++len, ++p;
+
+	if (namelen == (size_t) -1 && len == p - str) // fast path: verbatim copy
+		// already know the length; avoid the overhead of tal_strdup
+		return tal_dup_arr(ctx, char, str, len + 1, 0);
+
+	// allocate an appropriately sized buffer and produce the string
+	ret = r = tal_arr(ctx, char, len + 1);
+	for (p = str; *p && len;)
+		if (*p == '\\' && p[1])
+			*r++ = p[1], --len, p += 2;
+		else if (*p == '$') {
+			const char *name = ++p;
+			if (*p == '{') {
+				namelen = wordlen(name = ++p);
+				if (name[namelen] != '}') {
+					*r++ = '$', --len;
+					if (len)
+						*r++ = '{', --len;
+					continue;
+				}
+				p += namelen + 1; // }
+			}
+			else if (isdigit((unsigned char) *p))
+				p += (namelen = 1 + numlen(p + 1));
+			else if (iswordc((unsigned char) *p))
+				p += (namelen = 1 + wordlen(p + 1));
+			else {
+				*r++ = '$', --len;
+				continue;
+			}
+			sub = subst(ptr, name, namelen);
+			if (sub) {
+				size_t n = strnlen(sub, len);
+				memcpy(r, sub, n);
+				r += n, len -= n;
+			}
+			if (taken(sub))
+				tal_free(sub);
+		}
+		else
+			*r++ = *p++, --len;
+	*r = '\0';
+	assert(!len); // our buffer should be exactly the right size
+
+	if (taken(str))
+		tal_free(str);
+
+	return ret;
+}
+
+const char *subst_getenv(const void *defaults,
+                         const char *name,
+                         size_t namelen)
+{
+	char *ret, *mut;
+
+	if (name[namelen] == '\0')
+		return getenv(name);
+
+	mut = tal_dup_arr(NULL, char, name, namelen, 1);
+	mut[namelen] = '\0';
+	ret = getenv(mut);
+	tal_free(mut);
+
+	if (!ret && defaults)
+		for (const char *const *d = defaults; *d; ++d)
+			if (strncmp(*d, name, namelen) == 0 && (*d)[namelen] == '=')
+				return *d + namelen + 1;
+
+	return ret;
+}
diff --git a/common/utils.h b/common/utils.h
index cc49aa3b5a7..244ff9ada31 100644
--- a/common/utils.h
+++ b/common/utils.h
@@ -158,4 +158,63 @@ int tmpdir_mkstemp(const tal_t *ctx, const char *template TAKES, char **created)
  */
 char *str_lowering(const void *ctx, const char *string TAKES);
 
+/**
+ * str_expand: substitute variable references in string via callback function.
+ * @ctx: the tal context from which to allocate the returned string.
+ * @str: the string containing variable references as described below.
+ * @subst: a callback function to resolve variable names to values.
+ * @ptr: an opaque pointer to be passed as the first parameter to @subst.
+ *
+ * Variable references in @str are of the same form used by the POSIX shell,
+ * a dollar sign followed by exactly one of the following:
+ *  - a brace-enclosed word,
+ *  - an ASCII decimal number of any non-zero length,
+ *  - a word not beginning with a digit.
+ * Here, a "word" means any non-empty run of word characters, which are
+ * underscores or characters for which isalnum() returns true.
+ *
+ * A partial match of one of the above productions is not an error and does not
+ * produce a substitution; the characters are simply copied verbatim.
+ *
+ * For each variable reference encountered in @str, the @subst callback
+ * function is invoked, passing @ptr, a pointer to the name of the variable
+ * being referenced, and the length of the variable name. The function must
+ * return a pointer to a string containing the value to be substituted or NULL.
+ * If the pointer is returned as take(), then this function will tal_free() it.
+ * If the pointer returned is NULL, then the empty string will be substituted.
+ *
+ * Within the context of one invocation of str_expand(), the @subst callback
+ * function must be invariant with respect to the length of the string that it
+ * returns for each distinct given variable name.
+ *
+ * Returns a copy of @str with all substitutions made.
+ *
+ * Example:
+ * const char *str = "How about a ${adj} ${game of $game?";
+ * If subst is a function that returns "nice" when passed "adj" and "chess"
+ * when passed "game", then str_expand(NULL, str, subst, NULL) will return
+ * "How about a nice ${game of chess?"
+ */
+char *str_expand(const void *ctx,
+                 const char *str TAKES,
+                 const char *TAKES (*subst)(const void *ptr,
+                                            const char *name,
+                                            size_t namelen),
+                 const void *ptr);
+
+/**
+ * subst_getenv: callback function for str_expand to get variables from environ
+ * @defaults: pointer to a NULL-terminated array of pointers to strings in the
+ * style of environ, providing default values for variables not found in the
+ * environment, or NULL if no defaults are to be provided.
+ * @name: name of an environment variable (which need not be NUL-terminated)
+ * @namelen: length of name
+ *
+ * This function is a suitable callback for str_expand when variable references
+ * are to be resolved using getenv().
+ */
+const char *subst_getenv(const void *defaults,
+                         const char *name,
+                         size_t namelen);
+
 #endif /* LIGHTNING_COMMON_UTILS_H */

From aa9c5b5bee99f7ae458aef34810ea3155e28e3cf Mon Sep 17 00:00:00 2001
From: Matt Whitlock <c-lightning@mattwhitlock.name>
Date: Mon, 4 Sep 2023 04:09:53 -0400
Subject: [PATCH 3/3] renepay: write test logs at $TMPDIR/debug.txt

Changelog-None
---
 plugins/renepay/debug.c                | 19 ++++++++++++++-----
 plugins/renepay/debug.h                |  2 +-
 plugins/renepay/test/run-mcf-diamond.c |  2 +-
 plugins/renepay/test/run-mcf.c         |  2 +-
 plugins/renepay/test/run-testflow.c    |  3 +--
 5 files changed, 18 insertions(+), 10 deletions(-)

diff --git a/plugins/renepay/debug.c b/plugins/renepay/debug.c
index 7394dd5d5b9..8fd44f2aaab 100644
--- a/plugins/renepay/debug.c
+++ b/plugins/renepay/debug.c
@@ -1,16 +1,25 @@
 #include "config.h"
+#include <common/utils.h>
 #include <plugins/renepay/debug.h>
 
+static FILE *fopen_expand(const char *fname, const char *mode) {
+	static const char *defaults[] = { "TMPDIR=/tmp", NULL };
+	char *xfname = str_expand(NULL, fname, subst_getenv, defaults);
+	FILE *f = fopen(xfname, mode);
+	tal_free(xfname);
+	return f;
+}
+
 void _debug_exec_branch(const char* fname,const char* fun, int lineno)
 {
-	FILE *f = fopen(fname,"a");
+	FILE *f = fopen_expand(fname,"a");
 	fprintf(f,"executing line: %d (%s)\n",lineno,fun);
 	fclose(f);
 }
 
 void _debug_outreq(const char *fname, const struct out_req *req)
 {
-	FILE *f = fopen(fname,"a");
+	FILE *f = fopen_expand(fname,"a");
 	size_t len;
 	const char * str =  json_out_contents(req->js->jout,&len);
 	fprintf(f,"%s",str);
@@ -22,14 +31,14 @@ void _debug_outreq(const char *fname, const struct out_req *req)
 
 void _debug_call(const char* fname, const char* fun)
 {
-	FILE *f = fopen(fname,"a");
+	FILE *f = fopen_expand(fname,"a");
 	fprintf(f,"calling function: %s\n",fun);
 	fclose(f);
 }
 
 void _debug_reply(const char* fname, const char* buf,const jsmntok_t *toks)
 {
-	FILE *f = fopen(fname,"a");
+	FILE *f = fopen_expand(fname,"a");
 	fprintf(f,"%.*s\n\n",
 		   json_tok_full_len(toks),
 		   json_tok_full(buf, toks));
@@ -38,7 +47,7 @@ void _debug_reply(const char* fname, const char* buf,const jsmntok_t *toks)
 
 void _debug_info(const char* fname, const char *fmt, ...)
 {
-	FILE *f = fopen(fname,"a");
+	FILE *f = fopen_expand(fname,"a");
 
 	va_list args;
 	va_start(args, fmt);
diff --git a/plugins/renepay/debug.h b/plugins/renepay/debug.h
index eb35e461454..9e1be95894e 100644
--- a/plugins/renepay/debug.h
+++ b/plugins/renepay/debug.h
@@ -17,7 +17,7 @@ void _debug_call(const char* fname, const char* fun);
 void _debug_exec_branch(const char* fname,const char* fun, int lineno);
 
 #ifndef MYLOG
-#define MYLOG "/tmp/debug.txt"
+#define MYLOG "$TMPDIR/debug.txt"
 #endif
 
 
diff --git a/plugins/renepay/test/run-mcf-diamond.c b/plugins/renepay/test/run-mcf-diamond.c
index 6436e01c628..cb0e137b74c 100644
--- a/plugins/renepay/test/run-mcf-diamond.c
+++ b/plugins/renepay/test/run-mcf-diamond.c
@@ -1,6 +1,6 @@
 #include "config.h"
 
-#define RENEPAY_UNITTEST // logs are written in /tmp/debug.txt
+#define RENEPAY_UNITTEST // logs are written in $TMPDIR/debug.txt
 #include "../payment.c"
 #include "../flow.c"
 #include "../uncertainty_network.c"
diff --git a/plugins/renepay/test/run-mcf.c b/plugins/renepay/test/run-mcf.c
index 539e973584c..9e63b06f876 100644
--- a/plugins/renepay/test/run-mcf.c
+++ b/plugins/renepay/test/run-mcf.c
@@ -1,6 +1,6 @@
 #include "config.h"
 
-#define RENEPAY_UNITTEST // logs are written in /tmp/debug.txt
+#define RENEPAY_UNITTEST // logs are written in $TMPDIR/debug.txt
 #include "../payment.c"
 #include "../flow.c"
 #include "../uncertainty_network.c"
diff --git a/plugins/renepay/test/run-testflow.c b/plugins/renepay/test/run-testflow.c
index 8b5111b255d..eac091b7b63 100644
--- a/plugins/renepay/test/run-testflow.c
+++ b/plugins/renepay/test/run-testflow.c
@@ -9,8 +9,7 @@
 #include <common/node_id.h>
 #include <ccan/read_write_all/read_write_all.h>
 
-#define MYLOG "/tmp/debug.txt"
-#define RENEPAY_UNITTEST // logs are written in MYLOG
+#define RENEPAY_UNITTEST // logs are written in $TMPDIR/debug.txt
 #include "../payment.c"
 #include "../flow.c"
 #include "../uncertainty_network.c"
